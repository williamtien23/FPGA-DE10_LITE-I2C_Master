
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module I2C_Master_Top(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50,
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	inout 		    [35:0]		GPIO
);



//=======================================================
//  REG/WIRE declarations
//=======================================================


reg start = 0;
reg write = 1;
reg [1:0] num_bytes = 2;
reg [6:0] address = 7'h10;
reg [7:0] register = 8'h0;
wire fifo_read;
wire dv;
wire busy;

wire sda_oen;
wire sda_o;
wire sda_i;
wire scl_oen;
wire scl_o;
wire scl_i;

reg [7:0] data_tx = 8'h0; 
wire [7:0] data_rx;

reg [15:0] data_rx_buffer = 16'd0;

reg [7:0] quotient_10k, quotient_1k, quotient_100, quotient_10;
reg [15:0] remainder_10k, remainder_1k;
reg [7:0] remainder_100, remainder_10;

reg [3:0] BCD_State = 0;
reg [19:0] BCD;
reg [7:0] state = STATE_INIT_WRITE;	
reg [31:0] count = 0;
reg [1:0] fifo_read_posedge;
reg [1:0] dv_posedge;


assign GPIO[0] = sda_oen ? sda_o : 1'bz;
assign sda_i = GPIO[0];

assign GPIO[1] = scl_oen ? scl_o : 1'bz;
assign scl_i = GPIO[1];


I2C_Master i2c_controller (.Clk(MAX10_CLK1_50), .Start(start), .Write(write), .Num_Bytes(num_bytes), .Address(address), .Register(register), .Buff_Next(fifo_read), .DV(dv), .Busy(busy), 
					 .I2C_SDA_OEn(sda_oen), .I2C_SDA_O(sda_o), .I2C_SDA_I(sda_i), .I2C_SCL_OEn(scl_oen), .I2C_SCL_O(scl_o), .I2C_SCL_I(scl_i),
					 .Data_Tx(data_tx), .Data_Rx(data_rx));
					 
Decoder_7seg decoder_1(.out(HEX0[6:0]), .in(BCD[3:0]));
Decoder_7seg decoder_2(.out(HEX1[6:0]), .in(BCD[7:4]));
Decoder_7seg decoder_3(.out(HEX2[6:0]), .in(BCD[11:8]));
Decoder_7seg decoder_4(.out(HEX3[6:0]), .in(BCD[15:12]));
Decoder_7seg decoder_5(.out(HEX4[6:0]), .in(BCD[19:16]));
//Decoder_7seg decoder_6(.out(HEX5[6:0]), .in(BCD_State));
					 
localparam STATE_INIT_WRITE		= 8'd0;
localparam STATE_WRITE 				= 8'd1;
localparam STATE_INIT_READ			= 8'd2;
localparam STATE_READ 				= 8'd3;
localparam STATE_OUTPUT				= 8'd4;
localparam STATE_DELAY 				= 8'd5;
//=======================================================
//  Structural coding
//=======================================================

always @ (posedge MAX10_CLK1_50) begin
	case(state)
		STATE_INIT_WRITE: begin
			start <= 1;
			address <= 7'h10;
			register <= 8'h0;
			num_bytes <= 2;
			BCD_State <= 1;
			if(busy)
				state <= STATE_WRITE;
		end
		
		STATE_WRITE: begin
			start <= 0;
			BCD_State <= 2;
			if(!fifo_read_posedge[1] && fifo_read_posedge[0])
				data_tx = 8'h13;
			if(!busy)
				state <= STATE_INIT_READ;
		end
		
		STATE_INIT_READ: begin
			start <= 1;
			address <= 7'h10;
			register <= 8'h4;
			num_bytes <= 2;
			BCD_State <= 3;
			write = 0;
			if(busy)
				state <= STATE_READ;
			count <= 4;
		end
		
		STATE_READ: begin
			start <= 0;
			BCD_State <= 4;
			if(!dv_posedge[1] && dv_posedge[0]) begin
				data_rx_buffer[15:8] <= data_rx;
				data_rx_buffer[7:0] <= data_rx_buffer[15:8];
			end
			if(!busy)
				state <= STATE_OUTPUT;
		end	
		
		STATE_OUTPUT: begin
			BCD_State <= 5;
			if (count == 0) begin
				BCD[19:16] <= quotient_10k;//Pipeline5
				BCD[15:12] <= quotient_1k;	
				BCD[11:8] <= quotient_100;
				BCD[7:4] <= quotient_10;
				BCD[3:0] <= remainder_10;
				state <= STATE_DELAY;
			end
			else begin
				quotient_10k <= data_rx_buffer/'d10000; //Pipeline 1
				remainder_10k <= data_rx_buffer%'d10000;
				quotient_1k <= remainder_10k/'d1000; //Pipeline2
				remainder_1k <= remainder_10k%'d1000;
				quotient_100 <= remainder_1k/'d100; //Pipeline3
				remainder_100 <= remainder_1k%'d100;
				quotient_10 <= remainder_100/'d10;//Pipeline4
				remainder_10 <= remainder_100%'d10;
				count <= count-1;
			end
		end
		
		STATE_DELAY: begin
			BCD_State <= 6;
			if(count == 25000000)
				state <= STATE_INIT_READ;
			else
				count <= count+1;
		end
		
		default: state <= STATE_INIT_WRITE;
		
	endcase
end

always @ (posedge MAX10_CLK1_50) begin
	fifo_read_posedge[1] <= fifo_read_posedge[0];
	fifo_read_posedge[0] <= fifo_read;
	dv_posedge[1] <= dv_posedge[0];
	dv_posedge[0] <= dv;
end

endmodule
